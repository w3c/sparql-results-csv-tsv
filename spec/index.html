<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8" />
    <meta name="color-scheme" content="light dark" />
    <title>SPARQL 1.2 Query Results CSV and TSV Formats</title>

    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script src="./common/local-biblio.js" class="remove"></script>
    <script src="./common/fixup.js" class="remove"></script>

    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        group:                "rdf-star" ,
        localBiblio:          localBibliography,
        specStatus:           "ED",
        edDraftURI:           "https://w3c.github.io/sparql-results-csv-tsv/spec/",
        testSuiteURI:         "https://w3c.github.io/rdf-tests/",
        shortName:            "sparql12-results-csv-tsv",
        copyrightStart:       "2012",
         
        github:               "https://github.com/w3c/sparql-results-csv-tsv",
        wgPublicList:         "public-rdf-star-wg",

//        implementationReportURI: "https://w3c.github.io/sparql12-results-csv-tsv/reports/",
//        errata:               "https://w3c.github.io/sparql12-results-csv-tsv/errata/",

        previousPublishDate:  "2013-03-21",
        prevRecURI:           "https://www.w3.org/TR/2013/REC-sparql11-results-csv-tsv-20130321",
        prevRecShortname:     "sparql11-results-csv-tsv",
        previousMaturity:     "REC",
        
        editors: [
          { name: "Ruben Taelman", w3cid: "84199"},
          { name: "Gregory Williams", w3cid: "38870"},
          { name: "Thomas Pellissier Tanon", w3cid: "73758"},
        ],
        formerEditors: [
          { name: "Andy Seaborne" },
        ],

        //doJsonLd:     true,
        
        lint: { "no-unused-dfns": false }
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>The formats CSV [[RFC4180]] (comma separated values) 
        and TSV [[IANA-TSV]] (tab separated values) provide simple, easy to process formats
        for the transmission of tabular data. They are supported as input datat formats by many tools,
        particularly spreadsheets. This document describes their use for expressing SPARQL query results
        from <code>SELECT</code> queries.</p>
    </section>

    <section id="sotd" class="introductory updateable-rec">
      <p>
        This specification is published by the
        <a href="https://www.w3.org/groups/wg/rdf-star">RDF Star Working Group</a> as part of the
        update of specifications for format and errata.
      </p>

      <section id="related" data-include="common/sparql-related.html"></section>
    </section>
    
<!-- BODY -->
    <section id="introduction">
    <h2>Introduction</h2>
    <p>This document describes CSV and TSV formats for expressing the results of a SPARQL <code>SELECT</code> query.
      They provide lowest common denominator formats between systems using different implementation technologies.</p>
    <p>Other formats for expression of SPARQL results are the SPARQL Results XML Format 
      [[SPARQL12-RESULTS-XML]] and 
      the SPARQL Results JSON Format [[SPARQL12-RESULTS-JSON]]. Each format is useful
      in different application scenarios.</p>
    <p>The SPARQL Results CSV Format is a lossy encoding of a table of results. It does not encode all the
      details of each RDF term in the results; instead, it just gives a string without indicating the type of the
      term (IRI, Literal, Literal with datatype, Literal with language, or blank node). This makes it simple to
      consume data, such as text and numbers, in applications that don't need to understand the details of RDF. In
      some applications, guesses as to which elements are hyperlinks are made pragmatically, for example, guessing
      that strings starting "<code>http://</code>" are links.</p>
    <p>The SPARQL Results TSV Format does encode the details of RDF terms in the results table, by using the syntax
      that SPARQL [[SPARQL12-QUERY]] and Turtle [[RDF12-TURTLE]] use. An application receiving
      a TSV-encoded result set can split each line into elements of the result row, and extract all the details of
      the RDF terms it wishes to process by simple string processing, without a complete XML or JSON parser as may 
      by required by the more complex SPARQL result formats.</p>

     <p>
       When this document uses the words MUST, MUST NOT, SHOULD, SHOULD NOT, and MAY, and the words
       appear as emphasized text, they must be interpreted as described in [[RFC2119]].
     </p>

      <section id="example1">
      <h3>Example</h3>
      <p>The following artificial example is used to illustrate the features of serializing results in each format.</p>
      <table class="data">
        <thead>
          <tr>
            <th>x</th>
            <th>literal</th>
            <th><i>Comment (not part of the table)</i></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>&lt;http://example/x&gt;</code></td>
            <td><code>String</code></td>
            <td>An IRI and a string consisting of characters S-t-r-i-n-g</td>
          </tr>
          <tr>
            <td><code>&lt;http://example/x&gt;</code></td>
            <td><code>String-with-dquote"</code></td>
            <td>String with a double quote in it.</td>
          </tr>
          <tr>
            <td><code>_:b0</code></td>
            <td><code>Blank node</code></td>
            <td>Blank node</td>
          </tr>
          <tr>
            <td></td>
            <td><code>Missing 'x'</code></td>
            <td>No RDF term for the <b>x</b> column</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td>This row has no terms in it.</td>
          </tr>
          <tr>
            <td><code>&lt;http://example/x&gt;</code></td>
            <td></td>
            <td>No term in the <b>literal</b> column.</td>
          </tr>
          <tr>
            <td><code>_:b1</code></td>
            <td><code>"String-with-lang"@en</code></td>
            <td>An RDF literal with a language tag</td>
          </tr>
          <tr>
            <td><code>_:b1</code></td>
            <td><code>"String-with-lang-dir"@en--ltr</code></td>
            <td>An RDF literal with a directional language tag</td>
          </tr>
          <tr>
            <td><code>_:b1</code></td>
            <td><code>123</code></td>
            <td>An RDF literal, datatype xsd:integer, and lexical form 123.</td>
          </tr>
        </tbody>
      </table>

      <p>The following artificial example is used to illustrate the features of serializing results containing triple terms.</p>
      <table class="data">
        <thead>
          <tr>
            <th>x</th>
            <th>triple</th>
            <th><i>Comment (not part of the table)</i></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>"Alice"</code></td>
            <td><code>&lt;&lt;( &lt;http://example/alice&gt; &lt;http://example/knows&gt; &lt;http://example/bob&gt; )&gt;&gt;</code></td>
            <td>A plain string and triple term with subject IRI <code>http://example/alice</code>, predicate IRI <code>http://example/knows</code>, and object IRI <code>http://example/bob</code>.</td>
          </tr>
          <tr>
            <td><code>"Bob"</code></td>
            <td><code>&lt;&lt;( &lt;http://example/bob&gt; &lt;http://example/knows&gt; &lt;http://example/alice&gt; )&gt;&gt;</code></td>
            <td>A plain string and triple term with subject IRI <code>http://example/bob</code>, predicate IRI <code>http://example/knows</code>, and object IRI <code>http://example/alice</code>.</td>
          </tr>
          <tr>
            <td><code>"Carol"</code></td>
            <td><code>&lt;&lt;( &lt;http://example/carol&gt; &lt;http://example/says&gt; "Hello world, my name is \"Alice\"." )&gt;&gt;</code></td>
            <td>A plain string and triple term with subject IRI <code>http://example/carol</code>, predicate IRI <code>http://example/says</code>, and object literal <code>Hello world, my name is "Alice".</code>.</td>
          </tr>
        </tbody>
      </table>
      </section>
    </section>
    <section id="general-comments">
    <h2>Transmission issues using CSV and TSV Formats</h2>
    <p>The SPARQL result formats described here conform to the formal specifications of the relevant formats, 
      Comma Separated values (CSV) [[RFC4180]] 
      and Tab Separated Value (TSV) [[IANA-TSV]].</p>
    <p>Systems providing these formats should note that the content types are <code>text/csv</code> for CSV and 
      <code>text/tab-separated-values</code> for TSV. Being <code>text/*</code>, the default character set
      is US-ASCII. The <code>charset</code> parameter SHOULD be used in
      conjunction with SPARQL Results; UTF-8 is recommended; giving us <code>text/csv; charset=utf-8</code> and
      <code>text/tab-separated-values; charset=utf-8</code>.</p>
    <p>The end-of-line in CSV is <code>CRLF</code>, i.e., Unicode codepoints 13 (<code>U+000D</code>) and 10 (<code>U+000A</code>).</p>
    <p>The end-of-line in TSV is <code>EOL</code>, i.e., Unicode codepoint 10 (<code>U+000A</code>).</p>
    <p>Applications reading these formats are advised to cope with both CRLF and LF as end of line markers and
      not rely on conformance to the formal specifications.</p>
    </section>
    
    <section id="csv-table">
    <h2>CSV â€” Comma Separated values</h2>
    <p>In the SPARQL Results CSV Format, the results table is serialized as one line listing the variables in
      the results, using the CSV header line, followed by one line for each query solution. (Note: a line may end up
      split by newlines in the data). Values in the results are:</p>
      <ul>
        <li>strings for 
          <ul>
            <li>URIs</li>
            <li>lexical forms of non-numeric XSD datatypes</li>
            <li>blank node labels</li>
            <li>triple terms</li>
          </ul>
        </li>
        <li>numbers for literals of numeric XSD datatypes</li>
      </ul>
      <section id="serializing-results">
      <h3>Serializing the Results Table</h3>
      <p>The first line of a SPARQL Results CSV Format response is the header line, giving the names of the variables
        used in the result set. The header line consists of the variable names, without leading question marks
        <code>?</code>, separated by commas.</p>
      <p>While the <code>text/csv</code> format does not require a header row, the SPARQL Results CSV Format 
        MUST use a header row. If the content type parameter
        <code>header</code> is used, it MUST be <code>header=present</code>.</p>
      <p>The remaining rows are the values of the results, with each binding determined by the position in the row,
        corresponding to the entry in the header line.</p>
      <p>If a variable is not bound, an empty field is used (e.g. <code>,,</code>). Each row MUST have the same number of fields, with each field corresponding to a
        binding to the variable in the header line in the same field position.</p>
      </section>

      <section id="csv-terms">
      <h3>Serializing RDF Terms</h3>
      <p>The entry in each field is the string corresponding to the RDF term value. (cf. SPARQL <code>STR()</code>)
        without syntax to denote what kind of term it is. The encoding quoting rules of CSV format must be used.</p>
      <p>Blank nodes use the <code>_:label</code> form from Turtle and SPARQL. Use of the same label indicates the
        same blank node within the result set but has no significance outside the result set.</p>
      <p>Triple terms are enclosed in <code>&lt;&lt;( &mldr; )&gt;&gt;</code>,
      as <code>&lt;&lt;( <em>subject</em> <em>predicate</em> <em>object</em> )&gt;&gt;</code>,
         where the <em>subject</em>, <em>predicate</em>, and <em>object</em> terms are recursively serialized.
         The serializations of <em>subject</em>, <em>predicate</em>, and <em>object</em>
         MUST be separated by a single space character
         (<small>SPACE</small>, code point 32, <code>U+0020</code>). The single space character preceding <em>subject</em>,
         and the single space character following <em>object</em> are optional, and are mainly valuable for human readability.
         If the <em>object</em> is a literal, then it MUST be encapsulated within
         a pair of quotation marks <code>""</code>.</p>
      <p>Fields containing any of 
        <code>"</code> (<small>QUOTATION MARK</small>, code point 34, <code>U+0022</code> in Unicode [[UNICODE]]),
        <code>,</code> (<small>COMMA</small>, code point 44, <code>U+002C</code>),
        <code>LF</code> (code point 10, <code>U+000A</code>), or
        <code>CR</code> (code point 13, <code>U+000D</code>)
        MUST be quoted using the quoting
        mechanism of RFC4180 [[RFC4180]].
        Fields are delimited by a pair of quotation marks <code>"</code> (code point <code>U+0022</code>). Within quoted strings, all
        characters except <code>"</code>, including new line characters, have their exact meaning â€” newlines do not
        end a CSV record. Inline <code>"</code> is written using a pair of quotation marks <code>""</code>.
        This quoting mechanism is applied recursively for terms in triple terms.</p>
      <p id="csv-terms-escaping" class="note">
        Since literals in the object position of triple terms are encapsulated within a pair of quotation marks <code>"</code>, and
        the full triple term is always encapsulated within quotation marks as well,
        this requires the subsequent escaping of the "inner" quotation marks encapsulating the literal.
        Such cases will result in triple terms in the form of <code>"&lt;&lt;( <em>subject</em> <em>predicate</em> ""<em>object-literal</em>"" )&gt;&gt;"</code>.</p>
      <p>The standard CSV format does not distinguish between missing values and empty strings. The SPARQL 1.2
        Results CSV Format uses the same representation for unbound variables as for variables bound to an empty
        string literal. The other SPARQL Result formats (based on JSON, TSV, or XML) can be used if this distinction
        is required.</p>
      </section>
    
      <section id="csv-example">
      <h3>Example of CSV-Serialized Results</h3>
      <pre class="csv">x,literal
http://example/x,String
http://example/x,"String-with-dquote"""
_:b0,Blank node
,Missing 'x'
,
http://example/x,
_:b1,String-with-lang
_:b1,String-with-lang-dir
_:b1,123</pre>
      </section>

      <section id="csv-example-triple-terms">
      <h3>Example of CSV-Serialized Results with Triple Terms</h3>
      <pre class="csv">x,triple
"Alice",&lt;&lt;( http://example/alice http://example/knows http://example/bob )&gt;&gt;
"Bob",&lt;&lt;( http://example/bob http://example/knows http://example/alice )&gt;&gt;
"Carol","&lt;&lt;( http://example/carol http://example/says ""Hello world, my name is """"Alice""""."" )&gt;&gt;"</pre>
      </section>
    </section>

    <section id="tsv">
    <h2>TSV â€” Tab Separated values</h2>
    <p>In the SPARQL Results TSV Format, the results table is serialized as one line listing the variables
      in the results, followed by one line for each query solution. All RDF terms used in the format are
      encoded in the format specified by Turtle [RDF12-TURTLE]
      except that the triple term forms for the lexical part of
      literals MUST NOT be used. These forms would allow raw
      newlines and tabs that are part of the TSV format. A TSV format SPARQL result set must use the
      single quoted literal forms, together with any necessary escapes such as <code>\t</code>, 
      <code>\n</code>, and <code>\r</code>.</p>

      <section id="tsv-table">
      <h3>Serializing the Results Table</h3>
      <p>The results table is serialized as one line listing the variables in the results, followed by
        one line for each query solution. This first line is required by the TSV format [[IANA-TSV]],
        unlike CSV, where it is optional.</p>
      <p>Variables are serialized in SPARQL syntax, using question mark <code>?</code> character followed
        by the variable name.</p>
      <p>Each row of the result set is serialized by sequence of RDF terms in SPARQL syntax, separated
        by a tab (Horizontal Tab, Unicode code point <code>U+0009</code>) character.</p>
      <p>If a variable is not bound in a row, an empty field is used. Each row MUST
        have the same number of fields, corresponding to the variables listed in the
        first row.</p>
      </section>

      <section id="tsv-terms">
      <h3>Serializing RDF Terms</h3>
      <p>The SPARQL Results TSV Format serializes RDF terms in the results table by using the syntax that
        SPARQL [[SPARQL12-QUERY]] and Turtle [[RDF12-TURTLE]] use.</p>

      <p>IRIs are enclosed in <code>&lt;...&gt;</code>, literals are enclosed with double quotes 
        <code>"</code>...<code>"</code> or single quotes <code>'</code> ...<code>'</code> with optional
        <code>@lang</code> or <code>^^</code> for datatype. IRIs are written enclosed in
        <code>&lt;...&gt;</code>. They MUST conform to the
        <a href="https://www.rfc-editor.org/rfc/rfc3987#section-2.2">IRI rule</a> of [[[RFC3987]]].
        Such IRIs include the IRI scheme and MUST NOT be
        <a data-cite="rfc3986#section-4.2">Relative Reference</a>. 
        This includes IRIs used as datatypes.
      </p>
      <p>Literals are written with the lexical form in quotes. Tab, newline, and carriage return characters
        (Unicode code points <code>U+0009</code> (tab), <code>U+0010</code> (line feed) and <code>U+0013</code>
        (carriage return)) are encoded in strings as <code>\t</code>, <code>\n</code> and <code>\r</code>
        respectively. The long string forms using triple quotes â€” <code>"""</code> or <code>'''</code> 
        â€” MUST NOT be used.</p>
      <p>The abbreviated forms for numbers (XSD integers, decimals, and doubles) SHOULD be used.</p>
      <p>Blank nodes use the <code>_:label</code> form from Turtle and SPARQL. Use of the same label
        indicates the same blank node within the result set, but has no significance outside the result set.</p>
      <p>Triple terms are enclosed in <code>&lt;&lt;( &mldr; )&gt;&gt;</code>,
      as in <code>&lt;&lt;(<em>subject</em> <em>predicate</em> <em>object</em>)&gt;&gt;</code>,
         where the <em>subject</em>, <em>predicate</em>, and <em>object</em> terms are recursively serialized.
         The serializations of <em>subject</em>, <em>predicate</em>, and <em>object</em>
         MUST be separated by a single space character
         (<small>SPACE</small>, code point 32, <code>U+0020</code>). The single space character preceding <em>subject</em>,
         and the single space character following <em>object</em> are optional, and are mainly valuable for human readability.</p>
      </section>

      <section id="tsv-example">
      <h3>Example of TSV-Serialized Results</h3>
      <p>Writing <code>&lt;TAB&gt;</code> for a raw tab character (Unicode code point <code>U+0009</code>):</p>
      <pre class="tsv">?x&lt;TAB&gt;?literal
&lt;http://example/x&gt;&lt;TAB&gt;"String"
&lt;http://example/x&gt;&lt;TAB&gt;"String-with-dquote\"" 
<!--  " Unconfuse ...  -->

_:blank0&lt;TAB&gt;"Blank node"
&lt;TAB&gt;"Missing 'x'"
&lt;TAB&gt;
&lt;http://example/x&gt;&lt;TAB&gt;
_:blank1&lt;TAB&gt;"String-with-lang"@en
_:blank1&lt;TAB&gt;"String-with-lang-dir"@en--ltr
_:blank1&lt;TAB&gt;123</pre>
      </section>

      <section id="tsv-example-triple-terms">
      <h3>Example of TSV-Serialized Results with Triple Terms</h3>
      <p>Writing <code>&lt;TAB&gt;</code> for a raw tab character (Unicode code point <code>U+0009</code>):</p>
      <pre class="tsv">?x&lt;TAB&gt;?triple
"Alice"&lt;TAB&gt;&lt;&lt;( &lt;http://example/alice&gt; &lt;http://example/knows&gt; &lt;http://example/bob&gt; )&gt;&gt;
"Bob"&lt;TAB&gt;&lt;&lt;( &lt;http://example/bob&gt; &lt;http://example/knows&gt; &lt;http://example/alice&gt; )&gt;&gt;
"Carol"&lt;TAB&gt;&lt;&lt;( &lt;http://example/carol&gt; &lt;http://example/says&gt; "Hello world, my name is \"Alice\". )&gt;&gt;</pre>
      </section>
    </section>

    <section id="conformance">
      <h2>Conformance</h2>
    </section>
    
    <section id="changes-1-1" class="appendix informative">
      <h2>Changes between SPARQL 1.1 Query Results CSV and TSV Formats and SPARQL 1.2 Query Results CSV and TSV Formats</h2>
      <ul>
        <li>Allow triple terms to be expressed in <a href="#csv-terms" class="sectionRef"></a> and <a href="#tsv-terms" class="sectionRef"></a></li>
        <li>Support directional language-tagged strings in <a href="#csv-terms" class="sectionRef"></a> and <a href="#tsv-terms" class="sectionRef"></a></li>
      </ul>
    </section>

<!-- BODY -->
    <section id="privacy">
      <h2>Privacy Considerations</h2>
      <p>TODO</p>
    </section>

    <section id="security">
      <h2>Security Considerations</h2>
      <p>TODO</p>
    </section>

    <section id="internationalization">
      <h2>Internationalization Considerations</h2>
      <p>TODO</p>                
    </section>

    <section id="index"></section>

  </body>
</html>
